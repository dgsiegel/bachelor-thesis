\chapter{Design, analysis and implementation of a prototype}
\label{chapter:prototype}

\section{Goal}

The goal is to develop a prototype, which can cull and evaluate data of one or
more users of the \Twitter{} social network. The produced data should then be
assigned to real persons, in order to create a fact sheet for a social
engineer. It should be shown, that it is easy to file employees of a certain
company or private persons, just by using legally available data, put online by
the individuals themselves. The filed data should then enable a social
engineer to do social engineering attacks against the weakest point.

The prototype developed for this work should make it possible to find persons
either by their username or by their real name.
It then should evaluate and display every possible information, which can be
gathered legally. The data should be saved locally, which the possibility to
update it.

\section{Used programming languages, tools and libraries}

For the prototype, the \textit{Python}\footnote{http://www.python.org/} programming
language was used. It is a dynamic object-oriented programming language, that
offers strong support with many tools and comes with a large amount of standard
libraries. \textit{Python} allows rapid prototyping, and has many libraries built
in, used for example to call the \Twitter{} API.

The plotting was done using the
\textit{matplotlib}\footnote{http://matplotlib.sourceforge.net/} library, which
is a 2D plotting library, which produces production quality figures and is easy
accessible through the \textit{Python} programming language.

\section{Description and blueprint of the prototype}
\comment{better title needed}

The prototype was developed in a modular approach, to allow easy extensibility
of the prototype. As the \Twitter{} API is in constant change, this helps to
keep the prototype working and making it easy to extend it for new data
sources.

Each information source is developed as a plugin. The plugin downloads the
required data, parses it and prepares an output, which then can be put together
to a fact sheet.

The structure of the prototype is outlined in figure \ref{fig:prototype_class}.
The starting point is the Prototype module, which holds the starting values,
loads the plugins, runs them and puts together the output. To allow further
searches for persons, the main module holds several options. The prototype
currently supports the following:

\begin{itemize}
  \item Search and analyze a user. If the username passed is not found, a
  search for the name passed is launched.
  \item Search for a specific keywords
  \item Search for a location
  \item Search for a range
\end{itemize}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=\textwidth]{prototype_class.1}
    \label{fig:prototype_class}
    \caption{UML class diagram of the developed prototype}
  \end{center}
\end{figure}

After choosing the option, the API object is created, passing the username and
password. If the username and password is empty, the prototype connects
anonymously to the \Twitter{} API.

\comment{SEQUENCE DIAGRAM OF TWITTER API CALL}

\lstset{language=python}
\lstinputlistingln{38}{38}{../src/prototype.py}

The API object creates itself and calls the \texttt{\_\_init\_\_()} method of
the \texttt{TwitterAPICall} object. This means, that the prototype has an
object of the \texttt{TwitterAPI} object, which then creates a new
\texttt{TwitterAPICall} object each time called. At the same time the
\texttt{FileCache} object is created and passed on, which simply stores the
values downloaded into files.
\lstinputlistingln{152}{156}{../src/twitterapi.py}

When the \texttt{TwitterAPICall} object is created, it fills it default values,
with the one passed by the \texttt{TwitterAPI} object.
\lstinputlistingln{55}{64}{../src/twitterapi.py}

The \texttt{\_\_getattr\_\_()} method, which is a Python default method, is
called every time an attribute of an object is accessed. The prototype exploits
this behaviour for the \Twitter{} API. For example, if the prototype wants to
call the API function \texttt{/users/show}, in the code it just calls the
method \texttt{twitter.users.show()}. The previous mentioned function then just
removes the not existing attribute and appends it as an argument to a new
\texttt{TwitterAPICall} object.
\lstinputlistingln{66}{71}{../src/twitterapi.py}

If there is no attribute left, the object function is called, where the
prototype exploits the Python intern function \texttt{\_\_call\_\_} to actually
connect to the \Twitter{} API and download data. The actual downloading is
quite trivial. The method just determines if a POST or GET HTTP request
is needed, puts together the username and password, if given, builds the
request URL, looks if it is already cached, if there are API calls available
and if so does the actual call to the \Twitter{} API. The result is then cached
by using the \texttt{FileCache} object.

\begin{figure}[htb]
  \begin{center}
    \includegraphics[width=0.75\textwidth]{prototype_activity.1}
    \caption{Activity diagram of a generic plugin}
    \label{fig:prototype_activity}
  \end{center}
\end{figure}

Next, the plugin system is initialized, which simply imports the plugin files
by using the Python method \texttt{\_\_import\_\_()}. The list
\texttt{PLUGINS\_ENABLED} just holds the plugins, which should get loaded, run
and displayed.
\lstinputlistingln{20}{24}{../src/plugin.py}

All plugins are children of the \texttt{Plugin} object, which just holds the
methods \texttt{download()}, \texttt{parse()} and \texttt{output()}. Those
methods have to be implemented by each plugin. Figure
\ref{fig:prototype_activity} shows, how a single plugin works.
\lstinputlistingln{8}{17}{../src/plugin.py}

Now, each plugin has to be addressed somehow. As it was dynamically loaded,
there is no structure, which holds the plugin itself yet. However, the
\texttt{Plugin} objects knows, which subclasses or children were loaded. The
method \texttt{find\_plugins()} returns a list of the loaded plugins. If a
plugin was not created yet, it creates the specific plugin object.
\lstinputlistingln{27}{35}{../src/plugin.py}

The prototype can now call the three methods \texttt{download()},
\texttt{parse()} and \texttt{output()} of each plugin. The output is merged
gets written to a file.

If a new plugin should be added, a new plugin object has to be created, which
implements the above mentioned methods. Each API call gets cached and therefore
it is no overhead, if several modules need the same data to work with. The API
object just downloads the required data once and then just passes the cached
data.
\lstinputlistingln{1}{22}{../src/plugins/testplugin.py}

